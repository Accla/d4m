#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Types;

# HELPER FUNCTIONS AND STRUCTURES

package ThriftHadoopFileSystem_setInactivityTimeoutPeriod_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_setInactivityTimeoutPeriod_args->mk_accessors( qw( periodInSeconds ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{periodInSeconds} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{periodInSeconds}) {
      $self->{periodInSeconds} = $vals->{periodInSeconds};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_setInactivityTimeoutPeriod_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{periodInSeconds});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_setInactivityTimeoutPeriod_args');
  if (defined $self->{periodInSeconds}) {
    $xfer += $output->writeFieldBegin('periodInSeconds', TType::I64, 1);
    $xfer += $output->writeI64($self->{periodInSeconds});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_setInactivityTimeoutPeriod_result;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_setInactivityTimeoutPeriod_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_setInactivityTimeoutPeriod_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_shutdown_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_shutdown_args->mk_accessors( qw( status ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{status} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_shutdown_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{status});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_shutdown_args');
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::I32, 1);
    $xfer += $output->writeI32($self->{status});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_shutdown_result;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_shutdown_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_shutdown_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_create_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_create_args->mk_accessors( qw( path ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_create_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_create_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_create_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_create_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_create_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ThriftHandle();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_create_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_createFile_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_createFile_args->mk_accessors( qw( path mode overwrite bufferSize block_replication blocksize ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
$self->{mode} = undef;
$self->{overwrite} = undef;
$self->{bufferSize} = undef;
$self->{block_replication} = undef;
$self->{blocksize} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{mode}) {
      $self->{mode} = $vals->{mode};
    }
    if (defined $vals->{overwrite}) {
      $self->{overwrite} = $vals->{overwrite};
    }
    if (defined $vals->{bufferSize}) {
      $self->{bufferSize} = $vals->{bufferSize};
    }
    if (defined $vals->{block_replication}) {
      $self->{block_replication} = $vals->{block_replication};
    }
    if (defined $vals->{blocksize}) {
      $self->{blocksize} = $vals->{blocksize};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_createFile_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{mode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{overwrite});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{bufferSize});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{block_replication});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{blocksize});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_createFile_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mode}) {
    $xfer += $output->writeFieldBegin('mode', TType::I16, 2);
    $xfer += $output->writeI16($self->{mode});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{overwrite}) {
    $xfer += $output->writeFieldBegin('overwrite', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{overwrite});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bufferSize}) {
    $xfer += $output->writeFieldBegin('bufferSize', TType::I32, 4);
    $xfer += $output->writeI32($self->{bufferSize});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{block_replication}) {
    $xfer += $output->writeFieldBegin('block_replication', TType::I16, 5);
    $xfer += $output->writeI16($self->{block_replication});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blocksize}) {
    $xfer += $output->writeFieldBegin('blocksize', TType::I64, 6);
    $xfer += $output->writeI64($self->{blocksize});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_createFile_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_createFile_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_createFile_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ThriftHandle();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_createFile_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_open_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_open_args->mk_accessors( qw( path ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_open_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_open_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_open_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_open_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_open_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ThriftHandle();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_open_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_append_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_append_args->mk_accessors( qw( path ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_append_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_append_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_append_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_append_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_append_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new ThriftHandle();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_append_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_write_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_write_args->mk_accessors( qw( handle data ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{handle} = undef;
$self->{data} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{handle}) {
      $self->{handle} = $vals->{handle};
    }
    if (defined $vals->{data}) {
      $self->{data} = $vals->{data};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_write_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{handle} = new ThriftHandle();
        $xfer += $self->{handle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^-1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{data});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_write_args');
  if (defined $self->{handle}) {
    $xfer += $output->writeFieldBegin('handle', TType::STRUCT, 1);
    $xfer += $self->{handle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{data}) {
    $xfer += $output->writeFieldBegin('data', TType::STRING, -1);
    $xfer += $output->writeString($self->{data});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_write_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_write_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_write_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_write_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_read_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_read_args->mk_accessors( qw( handle offset size ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{handle} = undef;
$self->{offset} = undef;
$self->{size} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{handle}) {
      $self->{handle} = $vals->{handle};
    }
    if (defined $vals->{offset}) {
      $self->{offset} = $vals->{offset};
    }
    if (defined $vals->{size}) {
      $self->{size} = $vals->{size};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_read_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{handle} = new ThriftHandle();
        $xfer += $self->{handle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^-1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{offset});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^-2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_read_args');
  if (defined $self->{handle}) {
    $xfer += $output->writeFieldBegin('handle', TType::STRUCT, 1);
    $xfer += $self->{handle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{offset}) {
    $xfer += $output->writeFieldBegin('offset', TType::I64, -1);
    $xfer += $output->writeI64($self->{offset});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{size}) {
    $xfer += $output->writeFieldBegin('size', TType::I32, -2);
    $xfer += $output->writeI32($self->{size});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_read_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_read_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_read_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_read_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_close_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_close_args->mk_accessors( qw( out ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{out} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{out}) {
      $self->{out} = $vals->{out};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_close_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{out} = new ThriftHandle();
        $xfer += $self->{out}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_close_args');
  if (defined $self->{out}) {
    $xfer += $output->writeFieldBegin('out', TType::STRUCT, 1);
    $xfer += $self->{out}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_close_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_close_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_close_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_close_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_rm_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_rm_args->mk_accessors( qw( path recursive ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
$self->{recursive} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{recursive}) {
      $self->{recursive} = $vals->{recursive};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_rm_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{recursive});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_rm_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recursive}) {
    $xfer += $output->writeFieldBegin('recursive', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{recursive});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_rm_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_rm_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_rm_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_rm_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_rename_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_rename_args->mk_accessors( qw( path dest ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
$self->{dest} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{dest}) {
      $self->{dest} = $vals->{dest};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_rename_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{dest} = new Pathname();
        $xfer += $self->{dest}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_rename_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dest}) {
    $xfer += $output->writeFieldBegin('dest', TType::STRUCT, 2);
    $xfer += $self->{dest}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_rename_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_rename_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_rename_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_rename_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_mkdirs_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_mkdirs_args->mk_accessors( qw( path ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_mkdirs_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_mkdirs_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_mkdirs_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_mkdirs_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_mkdirs_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_mkdirs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_exists_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_exists_args->mk_accessors( qw( path ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_exists_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_exists_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_exists_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_exists_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_exists_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_exists_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_stat_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_stat_args->mk_accessors( qw( path ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_stat_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_stat_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_stat_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_stat_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_stat_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new FileStatus();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_stat_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_listStatus_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_listStatus_args->mk_accessors( qw( path ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_listStatus_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_listStatus_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_listStatus_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_listStatus_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_listStatus_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{success} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $elem19 = new FileStatus();
            $xfer += $elem19->read($input);
            push(@{$self->{success}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_listStatus_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter20 (@{$self->{success}}) 
        {
          $xfer += ${iter20}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_chmod_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_chmod_args->mk_accessors( qw( path mode ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
$self->{mode} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{mode}) {
      $self->{mode} = $vals->{mode};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_chmod_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{mode});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_chmod_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mode}) {
    $xfer += $output->writeFieldBegin('mode', TType::I16, 2);
    $xfer += $output->writeI16($self->{mode});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_chmod_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_chmod_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_chmod_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_chmod_result');
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_chown_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_chown_args->mk_accessors( qw( path owner group ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
$self->{owner} = undef;
$self->{group} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{owner}) {
      $self->{owner} = $vals->{owner};
    }
    if (defined $vals->{group}) {
      $self->{group} = $vals->{group};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_chown_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{owner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{group});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_chown_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{owner}) {
    $xfer += $output->writeFieldBegin('owner', TType::STRING, 2);
    $xfer += $output->writeString($self->{owner});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group}) {
    $xfer += $output->writeFieldBegin('group', TType::STRING, 3);
    $xfer += $output->writeString($self->{group});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_chown_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_chown_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_chown_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_chown_result');
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_setReplication_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_setReplication_args->mk_accessors( qw( path replication ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
$self->{replication} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{replication}) {
      $self->{replication} = $vals->{replication};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_setReplication_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{replication});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_setReplication_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{replication}) {
    $xfer += $output->writeFieldBegin('replication', TType::I16, 2);
    $xfer += $output->writeI16($self->{replication});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_setReplication_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_setReplication_result->mk_accessors( qw( ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_setReplication_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_setReplication_result');
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_getFileBlockLocations_args;
use base('Class::Accessor');
ThriftHadoopFileSystem_getFileBlockLocations_args->mk_accessors( qw( path start length ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{path} = undef;
$self->{start} = undef;
$self->{length} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{path}) {
      $self->{path} = $vals->{path};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{length}) {
      $self->{length} = $vals->{length};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_getFileBlockLocations_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{path} = new Pathname();
        $xfer += $self->{path}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{length});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_getFileBlockLocations_args');
  if (defined $self->{path}) {
    $xfer += $output->writeFieldBegin('path', TType::STRUCT, 1);
    $xfer += $self->{path}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::I64, 2);
    $xfer += $output->writeI64($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{length}) {
    $xfer += $output->writeFieldBegin('length', TType::I64, 3);
    $xfer += $output->writeI64($self->{length});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystem_getFileBlockLocations_result;
use base('Class::Accessor');
ThriftHadoopFileSystem_getFileBlockLocations_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ouch} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ouch}) {
      $self->{ouch} = $vals->{ouch};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'ThriftHadoopFileSystem_getFileBlockLocations_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size21 = 0;
          $self->{success} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $elem26 = new BlockLocation();
            $xfer += $elem26->read($input);
            push(@{$self->{success}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ouch} = new ThriftIOException();
        $xfer += $self->{ouch}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHadoopFileSystem_getFileBlockLocations_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter27 (@{$self->{success}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ouch}) {
    $xfer += $output->writeFieldBegin('ouch', TType::STRUCT, 1);
    $xfer += $self->{ouch}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package ThriftHadoopFileSystemIf;

sub setInactivityTimeoutPeriod{
  my $self = shift;
  my $periodInSeconds = shift;

  die 'implement interface';
}
sub shutdown{
  my $self = shift;
  my $status = shift;

  die 'implement interface';
}
sub create{
  my $self = shift;
  my $path = shift;

  die 'implement interface';
}
sub createFile{
  my $self = shift;
  my $path = shift;
  my $mode = shift;
  my $overwrite = shift;
  my $bufferSize = shift;
  my $block_replication = shift;
  my $blocksize = shift;

  die 'implement interface';
}
sub open{
  my $self = shift;
  my $path = shift;

  die 'implement interface';
}
sub append{
  my $self = shift;
  my $path = shift;

  die 'implement interface';
}
sub write{
  my $self = shift;
  my $handle = shift;
  my $data = shift;

  die 'implement interface';
}
sub read{
  my $self = shift;
  my $handle = shift;
  my $offset = shift;
  my $size = shift;

  die 'implement interface';
}
sub close{
  my $self = shift;
  my $out = shift;

  die 'implement interface';
}
sub rm{
  my $self = shift;
  my $path = shift;
  my $recursive = shift;

  die 'implement interface';
}
sub rename{
  my $self = shift;
  my $path = shift;
  my $dest = shift;

  die 'implement interface';
}
sub mkdirs{
  my $self = shift;
  my $path = shift;

  die 'implement interface';
}
sub exists{
  my $self = shift;
  my $path = shift;

  die 'implement interface';
}
sub stat{
  my $self = shift;
  my $path = shift;

  die 'implement interface';
}
sub listStatus{
  my $self = shift;
  my $path = shift;

  die 'implement interface';
}
sub chmod{
  my $self = shift;
  my $path = shift;
  my $mode = shift;

  die 'implement interface';
}
sub chown{
  my $self = shift;
  my $path = shift;
  my $owner = shift;
  my $group = shift;

  die 'implement interface';
}
sub setReplication{
  my $self = shift;
  my $path = shift;
  my $replication = shift;

  die 'implement interface';
}
sub getFileBlockLocations{
  my $self = shift;
  my $path = shift;
  my $start = shift;
  my $length = shift;

  die 'implement interface';
}
package ThriftHadoopFileSystemRest;

sub new {
  my $classname=shift;
  my $impl     =shift;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub setInactivityTimeoutPeriod{
  my $self = shift;
  my $request = shift;

  my $periodInSeconds = ($request->{'periodInSeconds'}) ? $request->{'periodInSeconds'} : undef;
  return $self->{impl}->setInactivityTimeoutPeriod($periodInSeconds);
}

sub shutdown{
  my $self = shift;
  my $request = shift;

  my $status = ($request->{'status'}) ? $request->{'status'} : undef;
  return $self->{impl}->shutdown($status);
}

sub create{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  return $self->{impl}->create($path);
}

sub createFile{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $mode = ($request->{'mode'}) ? $request->{'mode'} : undef;
  my $overwrite = ($request->{'overwrite'}) ? $request->{'overwrite'} : undef;
  my $bufferSize = ($request->{'bufferSize'}) ? $request->{'bufferSize'} : undef;
  my $block_replication = ($request->{'block_replication'}) ? $request->{'block_replication'} : undef;
  my $blocksize = ($request->{'blocksize'}) ? $request->{'blocksize'} : undef;
  return $self->{impl}->createFile($path, $mode, $overwrite, $bufferSize, $block_replication, $blocksize);
}

sub open{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  return $self->{impl}->open($path);
}

sub append{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  return $self->{impl}->append($path);
}

sub write{
  my $self = shift;
  my $request = shift;

  my $handle = ($request->{'handle'}) ? $request->{'handle'} : undef;
  my $data = ($request->{'data'}) ? $request->{'data'} : undef;
  return $self->{impl}->write($handle, $data);
}

sub read{
  my $self = shift;
  my $request = shift;

  my $handle = ($request->{'handle'}) ? $request->{'handle'} : undef;
  my $offset = ($request->{'offset'}) ? $request->{'offset'} : undef;
  my $size = ($request->{'size'}) ? $request->{'size'} : undef;
  return $self->{impl}->read($handle, $offset, $size);
}

sub close{
  my $self = shift;
  my $request = shift;

  my $out = ($request->{'out'}) ? $request->{'out'} : undef;
  return $self->{impl}->close($out);
}

sub rm{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $recursive = ($request->{'recursive'}) ? $request->{'recursive'} : undef;
  return $self->{impl}->rm($path, $recursive);
}

sub rename{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $dest = ($request->{'dest'}) ? $request->{'dest'} : undef;
  return $self->{impl}->rename($path, $dest);
}

sub mkdirs{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  return $self->{impl}->mkdirs($path);
}

sub exists{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  return $self->{impl}->exists($path);
}

sub stat{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  return $self->{impl}->stat($path);
}

sub listStatus{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  return $self->{impl}->listStatus($path);
}

sub chmod{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $mode = ($request->{'mode'}) ? $request->{'mode'} : undef;
  return $self->{impl}->chmod($path, $mode);
}

sub chown{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $owner = ($request->{'owner'}) ? $request->{'owner'} : undef;
  my $group = ($request->{'group'}) ? $request->{'group'} : undef;
  return $self->{impl}->chown($path, $owner, $group);
}

sub setReplication{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $replication = ($request->{'replication'}) ? $request->{'replication'} : undef;
  return $self->{impl}->setReplication($path, $replication);
}

sub getFileBlockLocations{
  my $self = shift;
  my $request = shift;

  my $path = ($request->{'path'}) ? $request->{'path'} : undef;
  my $start = ($request->{'start'}) ? $request->{'start'} : undef;
  my $length = ($request->{'length'}) ? $request->{'length'} : undef;
  return $self->{impl}->getFileBlockLocations($path, $start, $length);
}

package ThriftHadoopFileSystemClient;

use base('ThriftHadoopFileSystemIf');
sub new {
  my $classname = shift;
  my $input     = shift;
  my $output    = shift;
  my $self      = {};
    $self->{input}  = $input;
    $self->{output} = defined $output ? $output : $input;
    $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub setInactivityTimeoutPeriod{
  my $self = shift;
  my $periodInSeconds = shift;

    $self->send_setInactivityTimeoutPeriod($periodInSeconds);
  $self->recv_setInactivityTimeoutPeriod();
}

sub send_setInactivityTimeoutPeriod{
  my $self = shift;
  my $periodInSeconds = shift;

  $self->{output}->writeMessageBegin('setInactivityTimeoutPeriod', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_setInactivityTimeoutPeriod_args();
  $args->{periodInSeconds} = $periodInSeconds;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_setInactivityTimeoutPeriod{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_setInactivityTimeoutPeriod_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub shutdown{
  my $self = shift;
  my $status = shift;

    $self->send_shutdown($status);
  $self->recv_shutdown();
}

sub send_shutdown{
  my $self = shift;
  my $status = shift;

  $self->{output}->writeMessageBegin('shutdown', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_shutdown_args();
  $args->{status} = $status;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shutdown{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_shutdown_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub create{
  my $self = shift;
  my $path = shift;

    $self->send_create($path);
  return $self->recv_create();
}

sub send_create{
  my $self = shift;
  my $path = shift;

  $self->{output}->writeMessageBegin('create', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_create_args();
  $args->{path} = $path;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_create_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "create failed: unknown result";
}
sub createFile{
  my $self = shift;
  my $path = shift;
  my $mode = shift;
  my $overwrite = shift;
  my $bufferSize = shift;
  my $block_replication = shift;
  my $blocksize = shift;

    $self->send_createFile($path, $mode, $overwrite, $bufferSize, $block_replication, $blocksize);
  return $self->recv_createFile();
}

sub send_createFile{
  my $self = shift;
  my $path = shift;
  my $mode = shift;
  my $overwrite = shift;
  my $bufferSize = shift;
  my $block_replication = shift;
  my $blocksize = shift;

  $self->{output}->writeMessageBegin('createFile', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_createFile_args();
  $args->{path} = $path;
  $args->{mode} = $mode;
  $args->{overwrite} = $overwrite;
  $args->{bufferSize} = $bufferSize;
  $args->{block_replication} = $block_replication;
  $args->{blocksize} = $blocksize;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createFile{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_createFile_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "createFile failed: unknown result";
}
sub open{
  my $self = shift;
  my $path = shift;

    $self->send_open($path);
  return $self->recv_open();
}

sub send_open{
  my $self = shift;
  my $path = shift;

  $self->{output}->writeMessageBegin('open', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_open_args();
  $args->{path} = $path;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_open{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_open_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "open failed: unknown result";
}
sub append{
  my $self = shift;
  my $path = shift;

    $self->send_append($path);
  return $self->recv_append();
}

sub send_append{
  my $self = shift;
  my $path = shift;

  $self->{output}->writeMessageBegin('append', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_append_args();
  $args->{path} = $path;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_append{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_append_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "append failed: unknown result";
}
sub write{
  my $self = shift;
  my $handle = shift;
  my $data = shift;

    $self->send_write($handle, $data);
  return $self->recv_write();
}

sub send_write{
  my $self = shift;
  my $handle = shift;
  my $data = shift;

  $self->{output}->writeMessageBegin('write', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_write_args();
  $args->{handle} = $handle;
  $args->{data} = $data;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_write{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_write_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "write failed: unknown result";
}
sub read{
  my $self = shift;
  my $handle = shift;
  my $offset = shift;
  my $size = shift;

    $self->send_read($handle, $offset, $size);
  return $self->recv_read();
}

sub send_read{
  my $self = shift;
  my $handle = shift;
  my $offset = shift;
  my $size = shift;

  $self->{output}->writeMessageBegin('read', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_read_args();
  $args->{handle} = $handle;
  $args->{offset} = $offset;
  $args->{size} = $size;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_read{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_read_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "read failed: unknown result";
}
sub close{
  my $self = shift;
  my $out = shift;

    $self->send_close($out);
  return $self->recv_close();
}

sub send_close{
  my $self = shift;
  my $out = shift;

  $self->{output}->writeMessageBegin('close', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_close_args();
  $args->{out} = $out;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_close{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_close_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "close failed: unknown result";
}
sub rm{
  my $self = shift;
  my $path = shift;
  my $recursive = shift;

    $self->send_rm($path, $recursive);
  return $self->recv_rm();
}

sub send_rm{
  my $self = shift;
  my $path = shift;
  my $recursive = shift;

  $self->{output}->writeMessageBegin('rm', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_rm_args();
  $args->{path} = $path;
  $args->{recursive} = $recursive;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_rm{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_rm_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "rm failed: unknown result";
}
sub rename{
  my $self = shift;
  my $path = shift;
  my $dest = shift;

    $self->send_rename($path, $dest);
  return $self->recv_rename();
}

sub send_rename{
  my $self = shift;
  my $path = shift;
  my $dest = shift;

  $self->{output}->writeMessageBegin('rename', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_rename_args();
  $args->{path} = $path;
  $args->{dest} = $dest;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_rename{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_rename_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "rename failed: unknown result";
}
sub mkdirs{
  my $self = shift;
  my $path = shift;

    $self->send_mkdirs($path);
  return $self->recv_mkdirs();
}

sub send_mkdirs{
  my $self = shift;
  my $path = shift;

  $self->{output}->writeMessageBegin('mkdirs', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_mkdirs_args();
  $args->{path} = $path;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mkdirs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_mkdirs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "mkdirs failed: unknown result";
}
sub exists{
  my $self = shift;
  my $path = shift;

    $self->send_exists($path);
  return $self->recv_exists();
}

sub send_exists{
  my $self = shift;
  my $path = shift;

  $self->{output}->writeMessageBegin('exists', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_exists_args();
  $args->{path} = $path;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_exists{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_exists_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "exists failed: unknown result";
}
sub stat{
  my $self = shift;
  my $path = shift;

    $self->send_stat($path);
  return $self->recv_stat();
}

sub send_stat{
  my $self = shift;
  my $path = shift;

  $self->{output}->writeMessageBegin('stat', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_stat_args();
  $args->{path} = $path;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_stat{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_stat_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "stat failed: unknown result";
}
sub listStatus{
  my $self = shift;
  my $path = shift;

    $self->send_listStatus($path);
  return $self->recv_listStatus();
}

sub send_listStatus{
  my $self = shift;
  my $path = shift;

  $self->{output}->writeMessageBegin('listStatus', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_listStatus_args();
  $args->{path} = $path;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_listStatus{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_listStatus_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "listStatus failed: unknown result";
}
sub chmod{
  my $self = shift;
  my $path = shift;
  my $mode = shift;

    $self->send_chmod($path, $mode);
  $self->recv_chmod();
}

sub send_chmod{
  my $self = shift;
  my $path = shift;
  my $mode = shift;

  $self->{output}->writeMessageBegin('chmod', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_chmod_args();
  $args->{path} = $path;
  $args->{mode} = $mode;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_chmod{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_chmod_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  return;
}
sub chown{
  my $self = shift;
  my $path = shift;
  my $owner = shift;
  my $group = shift;

    $self->send_chown($path, $owner, $group);
  $self->recv_chown();
}

sub send_chown{
  my $self = shift;
  my $path = shift;
  my $owner = shift;
  my $group = shift;

  $self->{output}->writeMessageBegin('chown', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_chown_args();
  $args->{path} = $path;
  $args->{owner} = $owner;
  $args->{group} = $group;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_chown{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_chown_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  return;
}
sub setReplication{
  my $self = shift;
  my $path = shift;
  my $replication = shift;

    $self->send_setReplication($path, $replication);
  $self->recv_setReplication();
}

sub send_setReplication{
  my $self = shift;
  my $path = shift;
  my $replication = shift;

  $self->{output}->writeMessageBegin('setReplication', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_setReplication_args();
  $args->{path} = $path;
  $args->{replication} = $replication;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_setReplication{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_setReplication_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  return;
}
sub getFileBlockLocations{
  my $self = shift;
  my $path = shift;
  my $start = shift;
  my $length = shift;

    $self->send_getFileBlockLocations($path, $start, $length);
  return $self->recv_getFileBlockLocations();
}

sub send_getFileBlockLocations{
  my $self = shift;
  my $path = shift;
  my $start = shift;
  my $length = shift;

  $self->{output}->writeMessageBegin('getFileBlockLocations', TMessageType::CALL, $self->{seqid});
  my $args = new ThriftHadoopFileSystem_getFileBlockLocations_args();
  $args->{path} = $path;
  $args->{start} = $start;
  $args->{length} = $length;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getFileBlockLocations{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new ThriftHadoopFileSystem_getFileBlockLocations_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ouch}) {
    die $result->{ouch};
  }
  die "getFileBlockLocations failed: unknown result";
}
package ThriftHadoopFileSystemProcessor;

sub new {
    my $classname = shift;
    my $handler   = shift;
    my $self      = {};
    $self->{handler} = $handler;
    return bless($self,$classname);
}

sub process {
    my $self   = shift;
    my $input  = shift;
    my $output = shift;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!method_exists($self, $methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
  }

sub process_setInactivityTimeoutPeriod{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ThriftHadoopFileSystem_setInactivityTimeoutPeriod_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHadoopFileSystem_setInactivityTimeoutPeriod_result();
    $self->{handler}->setInactivityTimeoutPeriod($args->periodInSeconds);
      $output->writeMessageBegin('setInactivityTimeoutPeriod', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_shutdown{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ThriftHadoopFileSystem_shutdown_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHadoopFileSystem_shutdown_result();
    $self->{handler}->shutdown($args->status);
      $output->writeMessageBegin('shutdown', TMessageType::REPLY, $seqid);
      $result->write($output);
      $output->getTransport()->flush();
  }
sub process_create{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new ThriftHadoopFileSystem_create_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new ThriftHadoopFileSystem_create_result();
    eval {
      $result->{success} = $self->{handler}->create($args->path);
    }; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
      $result->{ouch} = $@;
    }
    $output->writeMessageBegin('create', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->getTransport()->flush();
}
sub process_createFile{
  my $self = shift;
  my ($seqid, $input, $output); 
  my $args = new ThriftHadoopFileSystem_createFile_args();
  $args->read($input);
  $input->readMessageEnd();
  my $result = new ThriftHadoopFileSystem_createFile_result();
  eval {
    $result->{success} = $self->{handler}->createFile($args->path, $args->mode, $args->overwrite, $args->bufferSize, $args->block_replication, $args->blocksize);
  }; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
    $result->{ouch} = $@;
  }
  $output->writeMessageBegin('createFile', TMessageType::REPLY, $seqid);
  $result->write($output);
  $output->getTransport()->flush();
}
sub process_open{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_open_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_open_result();
eval {
  $result->{success} = $self->{handler}->open($args->path);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
  $result->{ouch} = $@;
}
$output->writeMessageBegin('open', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_append{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_append_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_append_result();
eval {
$result->{success} = $self->{handler}->append($args->path);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('append', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_write{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_write_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_write_result();
eval {
$result->{success} = $self->{handler}->write($args->handle, $args->data);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('write', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_read{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_read_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_read_result();
eval {
$result->{success} = $self->{handler}->read($args->handle, $args->offset, $args->size);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('read', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_close{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_close_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_close_result();
eval {
$result->{success} = $self->{handler}->close($args->out);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('close', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_rm{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_rm_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_rm_result();
eval {
$result->{success} = $self->{handler}->rm($args->path, $args->recursive);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('rm', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_rename{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_rename_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_rename_result();
eval {
$result->{success} = $self->{handler}->rename($args->path, $args->dest);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('rename', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_mkdirs{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_mkdirs_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_mkdirs_result();
eval {
$result->{success} = $self->{handler}->mkdirs($args->path);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('mkdirs', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_exists{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_exists_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_exists_result();
eval {
$result->{success} = $self->{handler}->exists($args->path);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('exists', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_stat{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_stat_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_stat_result();
eval {
$result->{success} = $self->{handler}->stat($args->path);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('stat', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_listStatus{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_listStatus_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_listStatus_result();
eval {
$result->{success} = $self->{handler}->listStatus($args->path);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('listStatus', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_chmod{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_chmod_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_chmod_result();
eval {
$self->{handler}->chmod($args->path, $args->mode);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('chmod', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_chown{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_chown_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_chown_result();
eval {
$self->{handler}->chown($args->path, $args->owner, $args->group);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('chown', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_setReplication{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_setReplication_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_setReplication_result();
eval {
$self->{handler}->setReplication($args->path, $args->replication);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('setReplication', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_getFileBlockLocations{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new ThriftHadoopFileSystem_getFileBlockLocations_args();
$args->read($input);
$input->readMessageEnd();
my $result = new ThriftHadoopFileSystem_getFileBlockLocations_result();
eval {
$result->{success} = $self->{handler}->getFileBlockLocations($args->path, $args->start, $args->length);
}; if( UNIVERSAL::isa($@,'ThriftIOException') ){ 
$result->{ouch} = $@;
}
$output->writeMessageBegin('getFileBlockLocations', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
1;
