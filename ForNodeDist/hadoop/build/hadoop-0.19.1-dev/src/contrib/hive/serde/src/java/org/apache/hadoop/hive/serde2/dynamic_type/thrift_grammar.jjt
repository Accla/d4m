options {
 MULTI=true;
 STATIC = false;
 NODE_PREFIX = "DynamicSerDe";
}


PARSER_BEGIN(thrift_grammar)

package org.apache.hadoop.hive.serde2.dynamic_type;

import java.util.*;
import java.io.*;
import java.net.*;
import com.facebook.thrift.protocol.*;
import com.facebook.thrift.transport.*;
import org.apache.hadoop.hive.serde2.dynamic_type.*;

public class thrift_grammar {

    private List<String> include_path = null;

    // for computing the autogenerated field ids in thrift
    private  int field_val;

    // store types and tables
    // separately because one cannot use a table (ie service.method) as a Struct like type.
    protected Map<String,DynamicSerDeSimpleNode> types;
    protected Map<String,DynamicSerDeSimpleNode> tables;

    // system include path
    final private static String default_include_path[] = {  "/usr/local/include","/usr/include","/usr/local/include/thrift/if","/usr/local/include/fb303/if" };

    // need three params to differentiate between this and 2 param method auto generated since
    // some calls in the autogenerated code use null param for 2nd param and thus ambiguous.
    protected thrift_grammar(InputStream is, List<String> include_path, boolean junk) {
        this(is,null);
        this.types = new HashMap<String,DynamicSerDeSimpleNode> () ;
        this.tables = new HashMap<String,DynamicSerDeSimpleNode> () ;
        this.include_path = include_path;
        this.field_val = -1;
    }

    // find the file on the include path
    private static File findFile(String fname, List<String> include_path) {
        for(String path: include_path) {
            final String full = path + "/" + fname;
            File f = new File(full);
            if(f.exists()) {
                return f;
            }
        }
        return null;
    }

    public static void main(String args[]) {
        String filename = null;
        List<String> include_path = new ArrayList<String>();

        for(String path: default_include_path)  {
            include_path.add(path);
        }
        for(int i = 0; i < args.length; i++) {
            String arg = args[i];
            if(arg.equals("--include") && i + 1 < args.length) {
                include_path.add(args[++i]);
            }
            if(arg.equals("--file") && i + 1 < args.length) {
                filename = args[++i];
            }
        }

        InputStream is = System.in;
        if(filename != null) {
            try {
                  is = new FileInputStream(findFile(filename, include_path));
            } catch(IOException e) {
            }
        }
        thrift_grammar t = new thrift_grammar(is,include_path,false);

          try {
            t.Start();
        } catch (Exception e) {
            System.out.println("Parse error.");
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }
}

PARSER_END(thrift_grammar)



SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"#"(~["\n"])* ("\n"|"\r"|"\r\n")>
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/**
 * HELPER DEFINITIONS, COMMENTS, CONSTANTS, AND WHATNOT
 */

TOKEN:
{
<tok_const: "const">|
<tok_namespace : "namespace"> |
<tok_cpp_namespace: "cpp_namespace">|
<tok_cpp_include : "cpp_include">|
<tok_cpp_type: "cpp_type">|
<tok_java_package : "java_package">|
<tok_cocoa_prefix: "cocoa_prefix">|
<tok_csharp_namespace: "csharp_namespace">|
<tok_php_namespace: "php_namespace">|
<tok_py_module: "py_module">|
<tok_perl_package: "perl_package">|
<tok_ruby_namespace: "ruby_namespace">|
<tok_smalltalk_category: "smalltalk_category">|
<tok_smalltalk_prefix: "smalltalk_prefix">|
<tok_xsd_all: "xsd_all">|
<tok_xsd_optional: "xsd_optional">|
<tok_xsd_nillable: "xsd_nillable">|
<tok_xsd_namespace: "xsd_namespace">|
<tok_xsd_attrs: "xsd_attrs">|
<tok_include : "include">|
<tok_void : "void">|
<tok_bool : "bool">|
<tok_byte: "byte">|
<tok_i16: "i16">|
<tok_i32: "i32">|
<tok_i64: "i64">|
<tok_double: "double">|
<tok_string: "string">|
<tok_slist : "slist">|
<tok_senum: "senum">|
<tok_map: "map"> |
<tok_list: "list"> |
<tok_set: "set"> |
<tok_async: "async"> |
<tok_typedef: "typedef"> |
<tok_struct: "struct"> |
<tok_exception: "exception"> |
<tok_extends: "extends"> |
<tok_throws: "throws"> |
<tok_service: "service"> |
<tok_enum: "enum"> |
<tok_required: "required"> |
<tok_optional: "optional">
}

TOKEN: {

<tok_int_constant :  (["+","-"])?(["0"-"9"])+>
|
<tok_double_constant:   ["+","-"](<DIGIT>)*"."(<DIGIT>)+(["e","E"](["+","-"])?(<DIGIT>)+)?>
|
<IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>|"."|"_")*>
|
<#LETTER: (["a"-"z", "A"-"Z" ]) >
|
<#DIGIT: ["0"-"9"] >
|
<tok_literal:        "\""(~["\""])*"\""|"'"(~["'"])*"'">
|
<tok_st_identifier: ["a"-"z","A"-"Z","-"]([".","a"-"z","A"-"Z","_","0"-"9","-"])*>
}


SimpleNode Start() : {}
{
  HeaderList()  (Definition())+
 {
    return jjtThis;
  }
}

SimpleNode HeaderList() : {}
{
  (Header())*
 {
    return jjtThis;
  }

}

SimpleNode Header() : {}
{
  Include()
    {
    return jjtThis;
    }
| Namespace()
    {
    return jjtThis;
    }
}

SimpleNode Namespace() : {}
{
  <tok_namespace> <IDENTIFIER> <IDENTIFIER>
{
  return jjtThis;
}
|
<tok_cpp_namespace> <IDENTIFIER>
{
  return jjtThis;
}
|
<tok_cpp_include> <tok_literal>
{
  return jjtThis;
}
|
<tok_php_namespace> <IDENTIFIER>
{
  return jjtThis;
}
|
<tok_py_module> <IDENTIFIER>
{
  return jjtThis;
}
|
<tok_perl_package> <IDENTIFIER>
{
  return jjtThis;
}
|
<tok_ruby_namespace> <IDENTIFIER>
{
  return jjtThis;
}
|
<tok_smalltalk_category> <tok_st_identifier>
{
  return jjtThis;
}
|
<tok_smalltalk_prefix> <IDENTIFIER>
{
  return jjtThis;
}
|
<tok_java_package> <IDENTIFIER>
{
  return jjtThis;
}
|
<tok_cocoa_prefix> <IDENTIFIER>
{
  return jjtThis;
}
|
<tok_xsd_namespace> <tok_literal>
{
  return jjtThis;
}
|
<tok_csharp_namespace> <IDENTIFIER>
{
  return jjtThis;
}
}


SimpleNode Include() :  {
 String fname;
 boolean found = false;
}
{
   <tok_include>
   fname=<tok_literal>.image
{
    // bugbug somewhat fragile below substring expression
    fname = fname.substring(1,fname.length() - 1);

    // try to find the file on the include path
    File f = thrift_grammar.findFile(fname, this.include_path);
    if(f != null) {
        found = true;
        try {
            FileInputStream fis = new FileInputStream(f);
            thrift_grammar t = new thrift_grammar(fis,this.include_path, false);
            t.Start();
            fis.close();
            found = true;
            // add in what we found to our type and table tables.
            this.tables.putAll(t.tables);
            this.types.putAll(t.types);
        } catch (Exception e) {
            System.out.println("File: " + fname + " - Oops.");
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }
    if(!found) {
        throw new RuntimeException("include file not found: " + fname);
    }
    return jjtThis;
}
}


SimpleNode Definition() : {}
{
  Const()
    {
    return jjtThis;
    }
| Service()
    {
    return jjtThis;
    }
| TypeDefinition()
    {
    return jjtThis;
    }
}

SimpleNode TypeDefinition() : {}
{
  Typedef()
    {
   return jjtThis;
    }
| Enum()
    {
   return jjtThis;
    }
| Senum()
    {
   return jjtThis;
    }
| Struct()
    {
   return jjtThis;
    }
| Xception()
    {
   return jjtThis;
    }

}

DynamicSerDeTypedef Typedef() : {}
{
  <tok_typedef>
  DefinitionType()
  jjtThis.name = <IDENTIFIER>.image
    {
        // store the type for later retrieval
        this.types.put(jjtThis.name, jjtThis);
        return jjtThis;
    }
}


// returning void because we ignore this production.
void CommaOrSemicolon() : {}
{
  ","
|
  ";"
{
}
}

SimpleNode Enum() : {}
{
  <tok_enum> <IDENTIFIER> "{" EnumDefList() "}"
    {
    return jjtThis;
    }
}

SimpleNode EnumDefList() : {}
{
  (EnumDef())+
    {
    return jjtThis;
    }
}

SimpleNode EnumDef() : {}
{
  <IDENTIFIER> ["=" <tok_int_constant>] [CommaOrSemicolon()]
    {
    return jjtThis;
    }
}

SimpleNode Senum() : {}
{
  <tok_senum> <IDENTIFIER> "{" SenumDefList() "}"
    {
    return jjtThis;
    }
}

SimpleNode SenumDefList() : {}
{
  (SenumDef())+
    {
    return jjtThis;
    }
}

SimpleNode SenumDef() : {}
{
  <tok_literal> [CommaOrSemicolon()]
    {
    return jjtThis;
    }
}


SimpleNode Const() : {}
{
  <tok_const> FieldType() <IDENTIFIER> "=" ConstValue() [CommaOrSemicolon()]
    {
    return jjtThis;
    }
}

SimpleNode ConstValue() : {}
{
  <tok_int_constant>
    {
    }
| <tok_double_constant>
    {
    }
| <tok_literal>
    {
    }
| <IDENTIFIER>
    {
    }
| ConstList()
    {
    }
| ConstMap()
    {
    return jjtThis;
    }
}

SimpleNode ConstList() : {}
{
  "[" ConstListContents() "]"
    {
    return jjtThis;
    }
}

SimpleNode ConstListContents() : {}
{
  (ConstValue() [CommaOrSemicolon()])+
    {
    return jjtThis;
    }
}

SimpleNode ConstMap() : {}
{
  "{" ConstMapContents() "}"
    {
    return jjtThis;
    }
}

SimpleNode ConstMapContents() : {}
{
  (ConstValue() ":" ConstValue() [CommaOrSemicolon()])+
    {
    }
|
    {
    return jjtThis;
    }
}

DynamicSerDeStruct Struct() :  {

}
{
  <tok_struct>
  jjtThis.name = <IDENTIFIER>.image
  "{"
  FieldList()
  "}"
    {
   this.types.put(jjtThis.name,jjtThis);
    return jjtThis;
    }
}


SimpleNode Xception() : {}
{
  <tok_exception> <IDENTIFIER> "{" FieldList() "}"
    {
    return jjtThis;
    }
}


SimpleNode Service() : {}
{
  <tok_service>
  <IDENTIFIER>
  Extends()
  "{"
  FlagArgs()
  (Function())+
  UnflagArgs()
  "}"
    {
        // at some point, these should be inserted as a "db"
        return jjtThis;
    }
}

SimpleNode FlagArgs() : {}
{
    {
    return jjtThis;
    }
}

SimpleNode UnflagArgs() : {}
{
    {
    return jjtThis;
    }
}

SimpleNode Extends() : {}
{
  <tok_extends> <IDENTIFIER>
    {
    return jjtThis;
    }
|
    {
    return jjtThis;
    }
}


DynamicSerDeFunction Function() : {}
{
  // metastore ignores async and type
  Async()
  FunctionType()

  // the name of the function/table
  jjtThis.name = <IDENTIFIER>.image
  "("
  FieldList()
  ")"
  Throws()
  [CommaOrSemicolon()]

    {
        this.tables.put(jjtThis.name, jjtThis);
        return jjtThis;
    }
}

void Async() : {}
{
  <tok_async>
|
{}
}

void Throws() : {}
{
  <tok_throws> "(" FieldList() ")"
|
{}
}


// nothing special - just use the DynamicSerDeFieldList's children methods to access the fields
DynamicSerDeFieldList FieldList() : {
   this.field_val = -1;
}
{
  (Field())*    {
    return jjtThis;
  }
}


DynamicSerDeField Field() : {

 String fidnum = "";
 String fid;
}
{

  // parse the field id which is optional
  [fidnum=<tok_int_constant>.image ":"]

  // is this field required or optional? default is optional
  FieldRequiredness()

  // field type - obviously not optional
  FieldType()

   // the name of the field - not optional
  jjtThis.name = <IDENTIFIER>.image

  // does it have = some value?
  FieldValue()

  // take it or leave it
  [CommaOrSemicolon()]

    {
    if(fidnum.length() > 0) {
       int fidInt = Integer.valueOf(fidnum);
       jjtThis.fieldid = fidInt;
    } else {
       jjtThis.fieldid = this.field_val--;
    }
    return jjtThis;
    }
}



SimpleNode FieldRequiredness() : {}
{
  <tok_required>
    {
        return jjtThis;
    }
| <tok_optional>
    {
        return jjtThis;
    }
|
   {
    return jjtThis;
   }
}

SimpleNode FieldValue() : {}
{
  "="
     ConstValue()
    {
        return jjtThis;
    }
|
{
        return jjtThis;
}
}

SimpleNode DefinitionType() : {}
{
//  BaseType() xxx
  TypeString()
    {
    return jjtThis;
    }
| TypeBool()
    {
    return jjtThis;
    }
| Typei16()
    {
    return jjtThis;
    }
| Typei32()
    {
    return jjtThis;
    }
| Typei64()
    {
    return jjtThis;
    }
| TypeDouble()
    {
    return jjtThis;
    }
|  TypeMap()
    {
    return jjtThis;
    }
| TypeSet()
    {
    return jjtThis;
    }
| TypeList()
    {
    return jjtThis;
    }
}

void FunctionType() : {}
{
  FieldType()
| <tok_void>
{}
}

DynamicSerDeFieldType FieldType() : {
}

{
  TypeString()
    {
    return jjtThis;
    }
| TypeBool()
    {
    return jjtThis;
    }
| Typei16()
    {
    return jjtThis;
    }
| Typei32()
    {
    return jjtThis;
    }
| Typei64()
    {
    return jjtThis;
    }
| TypeDouble()
    {
    return jjtThis;
    }
|
   TypeMap()
    {
    return jjtThis;
    }
|
   TypeSet()
    {
    return jjtThis;
    }
|
   TypeList()
    {
    return jjtThis;
    }
|
  jjtThis.name = <IDENTIFIER>.image
    {
    return jjtThis;
    }
}

DynamicSerDeTypeString TypeString() : {}
{
  <tok_string>
  {
  return jjtThis;
  }
}

DynamicSerDeTypeByte TypeByte() : {
}
{
   <tok_byte>
   {
   return jjtThis;
   }
}

DynamicSerDeTypei16 Typei16() : {
}
{
  <tok_i16>
  {
   return jjtThis;
  }
}

DynamicSerDeTypei32 Typei32() : {}
{
  <tok_i32>
  {
   return jjtThis;
  }
}

DynamicSerDeTypei64 Typei64() : {}
{
  <tok_i64>
  {
   return jjtThis;
  }
}

DynamicSerDeTypeDouble TypeDouble() : {}
{
  <tok_double>
  {
   return jjtThis;
  }
}

DynamicSerDeTypeBool TypeBool() : {}
{
  <tok_bool>
  {
   return jjtThis;
  }
}

DynamicSerDeTypeMap TypeMap() : {}
{
  <tok_map>
   "<"
  FieldType()
  ","
  FieldType()
   ">"
    {
    return jjtThis;
    }
}

DynamicSerDeTypeSet TypeSet() : {}
{
  <tok_set>
  "<"

  FieldType()

  ">"
    {
    return jjtThis;
    }
}

DynamicSerDeTypeList TypeList() : {}
{
  <tok_list>
  "<"

  FieldType()

  ">"
    {
    return jjtThis;
    }
}
