#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def createTable(self, tableName, splitPoints):
    pass

  def deleteTable(self, tableName):
    pass

  def shutdown(self, stopTabletServers):
    pass

  def ping(self, ):
    pass

  def getTables(self, ):
    pass

  def setTableProperty(self, tablename, property, value):
    pass

  def removeTableProperty(self, tablename, property):
    pass

  def startScan(self, tablename, range, columns, batchSize):
    pass

  def continueScan(self, scanID):
    pass

  def closeScan(self, scanID):
    pass

  def lookup(self, tablename, ranges, columns, authorizations):
    pass

  def fetch(self, scanID):
    pass

  def closeBatch(self, scanID):
    pass

  def update(self, tableName, updates):
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def createTable(self, tableName, splitPoints):
    self.send_createTable(tableName, splitPoints)
    self.recv_createTable()

  def send_createTable(self, tableName, splitPoints):
    self._oprot.writeMessageBegin('createTable', TMessageType.CALL, self._seqid)
    args = createTable_args()
    args.tableName = tableName
    args.splitPoints = splitPoints
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createTable(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createTable_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.sec != None:
      raise result.sec
    if result.tce != None:
      raise result.tce
    return

  def deleteTable(self, tableName):
    self.send_deleteTable(tableName)
    self.recv_deleteTable()

  def send_deleteTable(self, tableName):
    self._oprot.writeMessageBegin('deleteTable', TMessageType.CALL, self._seqid)
    args = deleteTable_args()
    args.tableName = tableName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteTable(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteTable_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.sec != None:
      raise result.sec
    if result.tde != None:
      raise result.tde
    return

  def shutdown(self, stopTabletServers):
    self.send_shutdown(stopTabletServers)

  def send_shutdown(self, stopTabletServers):
    self._oprot.writeMessageBegin('shutdown', TMessageType.CALL, self._seqid)
    args = shutdown_args()
    args.stopTabletServers = stopTabletServers
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def ping(self, ):
    self.send_ping()
    self.recv_ping()

  def send_ping(self, ):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.sec != None:
      raise result.sec
    return

  def getTables(self, ):
    self.send_getTables()
    return self.recv_getTables()

  def send_getTables(self, ):
    self._oprot.writeMessageBegin('getTables', TMessageType.CALL, self._seqid)
    args = getTables_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getTables(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getTables_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.sec != None:
      raise result.sec
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getTables failed: unknown result");

  def setTableProperty(self, tablename, property, value):
    self.send_setTableProperty(tablename, property, value)
    return self.recv_setTableProperty()

  def send_setTableProperty(self, tablename, property, value):
    self._oprot.writeMessageBegin('setTableProperty', TMessageType.CALL, self._seqid)
    args = setTableProperty_args()
    args.tablename = tablename
    args.property = property
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setTableProperty(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setTableProperty_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.sec != None:
      raise result.sec
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setTableProperty failed: unknown result");

  def removeTableProperty(self, tablename, property):
    self.send_removeTableProperty(tablename, property)
    return self.recv_removeTableProperty()

  def send_removeTableProperty(self, tablename, property):
    self._oprot.writeMessageBegin('removeTableProperty', TMessageType.CALL, self._seqid)
    args = removeTableProperty_args()
    args.tablename = tablename
    args.property = property
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeTableProperty(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = removeTableProperty_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.sec != None:
      raise result.sec
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeTableProperty failed: unknown result");

  def startScan(self, tablename, range, columns, batchSize):
    self.send_startScan(tablename, range, columns, batchSize)
    return self.recv_startScan()

  def send_startScan(self, tablename, range, columns, batchSize):
    self._oprot.writeMessageBegin('startScan', TMessageType.CALL, self._seqid)
    args = startScan_args()
    args.tablename = tablename
    args.range = range
    args.columns = columns
    args.batchSize = batchSize
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startScan(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startScan_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.sec != None:
      raise result.sec
    if result.nst != None:
      raise result.nst
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startScan failed: unknown result");

  def continueScan(self, scanID):
    self.send_continueScan(scanID)
    return self.recv_continueScan()

  def send_continueScan(self, scanID):
    self._oprot.writeMessageBegin('continueScan', TMessageType.CALL, self._seqid)
    args = continueScan_args()
    args.scanID = scanID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_continueScan(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = continueScan_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.nssi != None:
      raise result.nssi
    if result.nst != None:
      raise result.nst
    raise TApplicationException(TApplicationException.MISSING_RESULT, "continueScan failed: unknown result");

  def closeScan(self, scanID):
    self.send_closeScan(scanID)

  def send_closeScan(self, scanID):
    self._oprot.writeMessageBegin('closeScan', TMessageType.CALL, self._seqid)
    args = closeScan_args()
    args.scanID = scanID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def lookup(self, tablename, ranges, columns, authorizations):
    self.send_lookup(tablename, ranges, columns, authorizations)
    return self.recv_lookup()

  def send_lookup(self, tablename, ranges, columns, authorizations):
    self._oprot.writeMessageBegin('lookup', TMessageType.CALL, self._seqid)
    args = lookup_args()
    args.tablename = tablename
    args.ranges = ranges
    args.columns = columns
    args.authorizations = authorizations
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_lookup(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = lookup_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "lookup failed: unknown result");

  def fetch(self, scanID):
    self.send_fetch(scanID)
    return self.recv_fetch()

  def send_fetch(self, scanID):
    self._oprot.writeMessageBegin('fetch', TMessageType.CALL, self._seqid)
    args = fetch_args()
    args.scanID = scanID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_fetch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = fetch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.nssi != None:
      raise result.nssi
    raise TApplicationException(TApplicationException.MISSING_RESULT, "fetch failed: unknown result");

  def closeBatch(self, scanID):
    self.send_closeBatch(scanID)

  def send_closeBatch(self, scanID):
    self._oprot.writeMessageBegin('closeBatch', TMessageType.CALL, self._seqid)
    args = closeBatch_args()
    args.scanID = scanID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def update(self, tableName, updates):
    self.send_update(tableName, updates)
    return self.recv_update()

  def send_update(self, tableName, updates):
    self._oprot.writeMessageBegin('update', TMessageType.CALL, self._seqid)
    args = update_args()
    args.tableName = tableName
    args.updates = updates
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = update_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.sec != None:
      raise result.sec
    if result.nst != None:
      raise result.nst
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["createTable"] = Processor.process_createTable
    self._processMap["deleteTable"] = Processor.process_deleteTable
    self._processMap["shutdown"] = Processor.process_shutdown
    self._processMap["ping"] = Processor.process_ping
    self._processMap["getTables"] = Processor.process_getTables
    self._processMap["setTableProperty"] = Processor.process_setTableProperty
    self._processMap["removeTableProperty"] = Processor.process_removeTableProperty
    self._processMap["startScan"] = Processor.process_startScan
    self._processMap["continueScan"] = Processor.process_continueScan
    self._processMap["closeScan"] = Processor.process_closeScan
    self._processMap["lookup"] = Processor.process_lookup
    self._processMap["fetch"] = Processor.process_fetch
    self._processMap["closeBatch"] = Processor.process_closeBatch
    self._processMap["update"] = Processor.process_update

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_createTable(self, seqid, iprot, oprot):
    args = createTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createTable_result()
    try:
      self._handler.createTable(args.tableName, args.splitPoints)
    except ThriftSecurityException, sec:
      result.sec = sec
    except TableCreationException, tce:
      result.tce = tce
    oprot.writeMessageBegin("createTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteTable(self, seqid, iprot, oprot):
    args = deleteTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteTable_result()
    try:
      self._handler.deleteTable(args.tableName)
    except ThriftSecurityException, sec:
      result.sec = sec
    except TableDeletionException, tde:
      result.tde = tde
    oprot.writeMessageBegin("deleteTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_shutdown(self, seqid, iprot, oprot):
    args = shutdown_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.shutdown(args.stopTabletServers)
    return

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    try:
      self._handler.ping()
    except ThriftSecurityException, sec:
      result.sec = sec
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getTables(self, seqid, iprot, oprot):
    args = getTables_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getTables_result()
    try:
      result.success = self._handler.getTables()
    except ThriftSecurityException, sec:
      result.sec = sec
    oprot.writeMessageBegin("getTables", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setTableProperty(self, seqid, iprot, oprot):
    args = setTableProperty_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setTableProperty_result()
    try:
      result.success = self._handler.setTableProperty(args.tablename, args.property, args.value)
    except ThriftSecurityException, sec:
      result.sec = sec
    oprot.writeMessageBegin("setTableProperty", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeTableProperty(self, seqid, iprot, oprot):
    args = removeTableProperty_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeTableProperty_result()
    try:
      result.success = self._handler.removeTableProperty(args.tablename, args.property)
    except ThriftSecurityException, sec:
      result.sec = sec
    oprot.writeMessageBegin("removeTableProperty", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startScan(self, seqid, iprot, oprot):
    args = startScan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startScan_result()
    try:
      result.success = self._handler.startScan(args.tablename, args.range, args.columns, args.batchSize)
    except ThriftSecurityException, sec:
      result.sec = sec
    except NoSuchTableException, nst:
      result.nst = nst
    oprot.writeMessageBegin("startScan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_continueScan(self, seqid, iprot, oprot):
    args = continueScan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = continueScan_result()
    try:
      result.success = self._handler.continueScan(args.scanID)
    except NoSuchScanIDException, nssi:
      result.nssi = nssi
    except NoSuchTableException, nst:
      result.nst = nst
    oprot.writeMessageBegin("continueScan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_closeScan(self, seqid, iprot, oprot):
    args = closeScan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.closeScan(args.scanID)
    return

  def process_lookup(self, seqid, iprot, oprot):
    args = lookup_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = lookup_result()
    result.success = self._handler.lookup(args.tablename, args.ranges, args.columns, args.authorizations)
    oprot.writeMessageBegin("lookup", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_fetch(self, seqid, iprot, oprot):
    args = fetch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = fetch_result()
    try:
      result.success = self._handler.fetch(args.scanID)
    except NoSuchScanIDException, nssi:
      result.nssi = nssi
    oprot.writeMessageBegin("fetch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_closeBatch(self, seqid, iprot, oprot):
    args = closeBatch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.closeBatch(args.scanID)
    return

  def process_update(self, seqid, iprot, oprot):
    args = update_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_result()
    try:
      result.success = self._handler.update(args.tableName, args.updates)
    except ThriftSecurityException, sec:
      result.sec = sec
    except NoSuchTableException, nst:
      result.nst = nst
    oprot.writeMessageBegin("update", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class createTable_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.LIST, 'splitPoints', (TType.STRING,None), None, ), # 2
  )

  def __init__(self, d=None):
    self.tableName = None
    self.splitPoints = None
    if isinstance(d, dict):
      if 'tableName' in d:
        self.tableName = d['tableName']
      if 'splitPoints' in d:
        self.splitPoints = d['splitPoints']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.splitPoints = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readString();
            self.splitPoints.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createTable_args')
    if self.tableName != None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.splitPoints != None:
      oprot.writeFieldBegin('splitPoints', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.splitPoints))
      for iter34 in self.splitPoints:
        oprot.writeString(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createTable_result:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'tce', (master.ttypes.TableCreationException, master.ttypes.TableCreationException.thrift_spec), None, ), # 2
  )

  def __init__(self, d=None):
    self.sec = None
    self.tce = None
    if isinstance(d, dict):
      if 'sec' in d:
        self.sec = d['sec']
      if 'tce' in d:
        self.tce = d['tce']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tce = master.ttypes.TableCreationException()
          self.tce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createTable_result')
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    if self.tce != None:
      oprot.writeFieldBegin('tce', TType.STRUCT, 2)
      self.tce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteTable_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.tableName = None
    if isinstance(d, dict):
      if 'tableName' in d:
        self.tableName = d['tableName']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteTable_args')
    if self.tableName != None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteTable_result:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'tde', (master.ttypes.TableDeletionException, master.ttypes.TableDeletionException.thrift_spec), None, ), # 2
  )

  def __init__(self, d=None):
    self.sec = None
    self.tde = None
    if isinstance(d, dict):
      if 'sec' in d:
        self.sec = d['sec']
      if 'tde' in d:
        self.tde = d['tde']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.tde = master.ttypes.TableDeletionException()
          self.tde.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteTable_result')
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    if self.tde != None:
      oprot.writeFieldBegin('tde', TType.STRUCT, 2)
      self.tde.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shutdown_args:

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'stopTabletServers', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.stopTabletServers = None
    if isinstance(d, dict):
      if 'stopTabletServers' in d:
        self.stopTabletServers = d['stopTabletServers']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.stopTabletServers = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shutdown_args')
    if self.stopTabletServers != None:
      oprot.writeFieldBegin('stopTabletServers', TType.BOOL, 1)
      oprot.writeBool(self.stopTabletServers)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shutdown_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shutdown_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_args:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_result:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.sec = None
    if isinstance(d, dict):
      if 'sec' in d:
        self.sec = d['sec']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTables_args:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTables_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getTables_result:

  thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.sec = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'sec' in d:
        self.sec = d['sec']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype38, _size35) = iprot.readSetBegin()
          for _i39 in xrange(_size35):
            _elem40 = iprot.readString();
            self.success.add(_elem40)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getTables_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.STRING, len(self.success))
      for iter41 in self.success:
        oprot.writeString(iter41)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setTableProperty_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'property', None, None, ), # 2
    (3, TType.STRING, 'value', None, None, ), # 3
  )

  def __init__(self, d=None):
    self.tablename = None
    self.property = None
    self.value = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'property' in d:
        self.property = d['property']
      if 'value' in d:
        self.value = d['value']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.property = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setTableProperty_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.property != None:
      oprot.writeFieldBegin('property', TType.STRING, 2)
      oprot.writeString(self.property)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setTableProperty_result:

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.sec = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'sec' in d:
        self.sec = d['sec']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setTableProperty_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeTableProperty_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'property', None, None, ), # 2
  )

  def __init__(self, d=None):
    self.tablename = None
    self.property = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'property' in d:
        self.property = d['property']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.property = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeTableProperty_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.property != None:
      oprot.writeFieldBegin('property', TType.STRING, 2)
      oprot.writeString(self.property)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeTableProperty_result:

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.sec = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'sec' in d:
        self.sec = d['sec']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeTableProperty_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startScan_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRUCT, 'range', (Range, Range.thrift_spec), None, ), # 2
    (3, TType.LIST, 'columns', (TType.STRUCT,(Column, Column.thrift_spec)), None, ), # 3
    (4, TType.I32, 'batchSize', None, None, ), # 4
  )

  def __init__(self, d=None):
    self.tablename = None
    self.range = None
    self.columns = None
    self.batchSize = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'range' in d:
        self.range = d['range']
      if 'columns' in d:
        self.columns = d['columns']
      if 'batchSize' in d:
        self.batchSize = d['batchSize']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.range = Range()
          self.range.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.columns = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = Column()
            _elem47.read(iprot)
            self.columns.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.batchSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startScan_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.range != None:
      oprot.writeFieldBegin('range', TType.STRUCT, 2)
      self.range.write(oprot)
      oprot.writeFieldEnd()
    if self.columns != None:
      oprot.writeFieldBegin('columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter48 in self.columns:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.batchSize != None:
      oprot.writeFieldBegin('batchSize', TType.I32, 4)
      oprot.writeI32(self.batchSize)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startScan_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (InitialScan, InitialScan.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nst', (NoSuchTableException, NoSuchTableException.thrift_spec), None, ), # 2
  )

  def __init__(self, d=None):
    self.success = None
    self.sec = None
    self.nst = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'sec' in d:
        self.sec = d['sec']
      if 'nst' in d:
        self.nst = d['nst']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = InitialScan()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nst = NoSuchTableException()
          self.nst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startScan_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    if self.nst != None:
      oprot.writeFieldBegin('nst', TType.STRUCT, 2)
      self.nst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class continueScan_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scanID', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.scanID = None
    if isinstance(d, dict):
      if 'scanID' in d:
        self.scanID = d['scanID']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scanID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('continueScan_args')
    if self.scanID != None:
      oprot.writeFieldBegin('scanID', TType.I64, 1)
      oprot.writeI64(self.scanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class continueScan_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ScanResult, ScanResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'nssi', (tabletserver.ttypes.NoSuchScanIDException, tabletserver.ttypes.NoSuchScanIDException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nst', (NoSuchTableException, NoSuchTableException.thrift_spec), None, ), # 2
  )

  def __init__(self, d=None):
    self.success = None
    self.nssi = None
    self.nst = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'nssi' in d:
        self.nssi = d['nssi']
      if 'nst' in d:
        self.nst = d['nst']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ScanResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.nssi = tabletserver.ttypes.NoSuchScanIDException()
          self.nssi.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nst = NoSuchTableException()
          self.nst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('continueScan_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.nssi != None:
      oprot.writeFieldBegin('nssi', TType.STRUCT, 1)
      self.nssi.write(oprot)
      oprot.writeFieldEnd()
    if self.nst != None:
      oprot.writeFieldBegin('nst', TType.STRUCT, 2)
      self.nst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeScan_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scanID', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.scanID = None
    if isinstance(d, dict):
      if 'scanID' in d:
        self.scanID = d['scanID']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scanID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeScan_args')
    if self.scanID != None:
      oprot.writeFieldBegin('scanID', TType.I64, 1)
      oprot.writeI64(self.scanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeScan_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeScan_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class lookup_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.LIST, 'ranges', (TType.STRUCT,(Range, Range.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'columns', (TType.STRUCT,(Column, Column.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'authorizations', (TType.I32,None), None, ), # 4
  )

  def __init__(self, d=None):
    self.tablename = None
    self.ranges = None
    self.columns = None
    self.authorizations = None
    if isinstance(d, dict):
      if 'tablename' in d:
        self.tablename = d['tablename']
      if 'ranges' in d:
        self.ranges = d['ranges']
      if 'columns' in d:
        self.columns = d['columns']
      if 'authorizations' in d:
        self.authorizations = d['authorizations']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.ranges = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = Range()
            _elem54.read(iprot)
            self.ranges.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.columns = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = Column()
            _elem60.read(iprot)
            self.columns.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.authorizations = []
          (_etype64, _size61) = iprot.readListBegin()
          for _i65 in xrange(_size61):
            _elem66 = iprot.readI32();
            self.authorizations.append(_elem66)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('lookup_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.ranges != None:
      oprot.writeFieldBegin('ranges', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.ranges))
      for iter67 in self.ranges:
        iter67.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.columns != None:
      oprot.writeFieldBegin('columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter68 in self.columns:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.authorizations != None:
      oprot.writeFieldBegin('authorizations', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.authorizations))
      for iter69 in self.authorizations:
        oprot.writeI32(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class lookup_result:

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
  )

  def __init__(self, d=None):
    self.success = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('lookup_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetch_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scanID', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.scanID = None
    if isinstance(d, dict):
      if 'scanID' in d:
        self.scanID = d['scanID']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scanID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetch_args')
    if self.scanID != None:
      oprot.writeFieldBegin('scanID', TType.I64, 1)
      oprot.writeI64(self.scanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetch_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ScanResult, ScanResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'nssi', (tabletserver.ttypes.NoSuchScanIDException, tabletserver.ttypes.NoSuchScanIDException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.nssi = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'nssi' in d:
        self.nssi = d['nssi']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ScanResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.nssi = tabletserver.ttypes.NoSuchScanIDException()
          self.nssi.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetch_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.nssi != None:
      oprot.writeFieldBegin('nssi', TType.STRUCT, 1)
      self.nssi.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeBatch_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scanID', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.scanID = None
    if isinstance(d, dict):
      if 'scanID' in d:
        self.scanID = d['scanID']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scanID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeBatch_args')
    if self.scanID != None:
      oprot.writeFieldBegin('scanID', TType.I64, 1)
      oprot.writeI64(self.scanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeBatch_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeBatch_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
    (2, TType.LIST, 'updates', (TType.STRUCT,(Mutation, Mutation.thrift_spec)), None, ), # 2
  )

  def __init__(self, d=None):
    self.tableName = None
    self.updates = None
    if isinstance(d, dict):
      if 'tableName' in d:
        self.tableName = d['tableName']
      if 'updates' in d:
        self.updates = d['updates']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.updates = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = Mutation()
            _elem75.read(iprot)
            self.updates.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_args')
    if self.tableName != None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.updates != None:
      oprot.writeFieldBegin('updates', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.updates))
      for iter76 in self.updates:
        iter76.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (data.ttypes.UpdateErrors, data.ttypes.UpdateErrors.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nst', (NoSuchTableException, NoSuchTableException.thrift_spec), None, ), # 2
  )

  def __init__(self, d=None):
    self.success = None
    self.sec = None
    self.nst = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'sec' in d:
        self.sec = d['sec']
      if 'nst' in d:
        self.nst = d['nst']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = data.ttypes.UpdateErrors()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nst = NoSuchTableException()
          self.nst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    if self.nst != None:
      oprot.writeFieldBegin('nst', TType.STRUCT, 2)
      self.nst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


