#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def startScan(self, credentials, extent, range, columns, batchSize, ssiList, ssio, authorizations):
    pass

  def continueScan(self, scanID):
    pass

  def closeScan(self, scanID):
    pass

  def startMultiScan(self, credentials, batch, columns, ssiList, ssio, authorizations):
    pass

  def continueMultiScan(self, scanID):
    pass

  def closeMultiScan(self, scanID):
    pass

  def startUpdate(self, credentials):
    pass

  def setUpdateTablet(self, updateID, keyExtent):
    pass

  def applyUpdate(self, updateID, mutation):
    pass

  def closeUpdate(self, updateID):
    pass

  def update(self, credentials, keyExtent, mutation):
    pass

  def bulkImport(self, credentials, files):
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def startScan(self, credentials, extent, range, columns, batchSize, ssiList, ssio, authorizations):
    self.send_startScan(credentials, extent, range, columns, batchSize, ssiList, ssio, authorizations)
    return self.recv_startScan()

  def send_startScan(self, credentials, extent, range, columns, batchSize, ssiList, ssio, authorizations):
    self._oprot.writeMessageBegin('startScan', TMessageType.CALL, self._seqid)
    args = startScan_args()
    args.credentials = credentials
    args.extent = extent
    args.range = range
    args.columns = columns
    args.batchSize = batchSize
    args.ssiList = ssiList
    args.ssio = ssio
    args.authorizations = authorizations
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startScan(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startScan_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.sec != None:
      raise result.sec
    if result.nste != None:
      raise result.nste
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startScan failed: unknown result");

  def continueScan(self, scanID):
    self.send_continueScan(scanID)
    return self.recv_continueScan()

  def send_continueScan(self, scanID):
    self._oprot.writeMessageBegin('continueScan', TMessageType.CALL, self._seqid)
    args = continueScan_args()
    args.scanID = scanID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_continueScan(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = continueScan_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.nssi != None:
      raise result.nssi
    if result.nste != None:
      raise result.nste
    raise TApplicationException(TApplicationException.MISSING_RESULT, "continueScan failed: unknown result");

  def closeScan(self, scanID):
    self.send_closeScan(scanID)

  def send_closeScan(self, scanID):
    self._oprot.writeMessageBegin('closeScan', TMessageType.CALL, self._seqid)
    args = closeScan_args()
    args.scanID = scanID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def startMultiScan(self, credentials, batch, columns, ssiList, ssio, authorizations):
    self.send_startMultiScan(credentials, batch, columns, ssiList, ssio, authorizations)
    return self.recv_startMultiScan()

  def send_startMultiScan(self, credentials, batch, columns, ssiList, ssio, authorizations):
    self._oprot.writeMessageBegin('startMultiScan', TMessageType.CALL, self._seqid)
    args = startMultiScan_args()
    args.credentials = credentials
    args.batch = batch
    args.columns = columns
    args.ssiList = ssiList
    args.ssio = ssio
    args.authorizations = authorizations
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startMultiScan(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startMultiScan_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.sec != None:
      raise result.sec
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startMultiScan failed: unknown result");

  def continueMultiScan(self, scanID):
    self.send_continueMultiScan(scanID)
    return self.recv_continueMultiScan()

  def send_continueMultiScan(self, scanID):
    self._oprot.writeMessageBegin('continueMultiScan', TMessageType.CALL, self._seqid)
    args = continueMultiScan_args()
    args.scanID = scanID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_continueMultiScan(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = continueMultiScan_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.nssi != None:
      raise result.nssi
    raise TApplicationException(TApplicationException.MISSING_RESULT, "continueMultiScan failed: unknown result");

  def closeMultiScan(self, scanID):
    self.send_closeMultiScan(scanID)
    return self.recv_closeMultiScan()

  def send_closeMultiScan(self, scanID):
    self._oprot.writeMessageBegin('closeMultiScan', TMessageType.CALL, self._seqid)
    args = closeMultiScan_args()
    args.scanID = scanID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_closeMultiScan(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = closeMultiScan_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.nssi != None:
      raise result.nssi
    raise TApplicationException(TApplicationException.MISSING_RESULT, "closeMultiScan failed: unknown result");

  def startUpdate(self, credentials):
    self.send_startUpdate(credentials)
    return self.recv_startUpdate()

  def send_startUpdate(self, credentials):
    self._oprot.writeMessageBegin('startUpdate', TMessageType.CALL, self._seqid)
    args = startUpdate_args()
    args.credentials = credentials
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startUpdate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startUpdate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.sec != None:
      raise result.sec
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startUpdate failed: unknown result");

  def setUpdateTablet(self, updateID, keyExtent):
    self.send_setUpdateTablet(updateID, keyExtent)

  def send_setUpdateTablet(self, updateID, keyExtent):
    self._oprot.writeMessageBegin('setUpdateTablet', TMessageType.CALL, self._seqid)
    args = setUpdateTablet_args()
    args.updateID = updateID
    args.keyExtent = keyExtent
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def applyUpdate(self, updateID, mutation):
    self.send_applyUpdate(updateID, mutation)

  def send_applyUpdate(self, updateID, mutation):
    self._oprot.writeMessageBegin('applyUpdate', TMessageType.CALL, self._seqid)
    args = applyUpdate_args()
    args.updateID = updateID
    args.mutation = mutation
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def closeUpdate(self, updateID):
    self.send_closeUpdate(updateID)
    return self.recv_closeUpdate()

  def send_closeUpdate(self, updateID):
    self._oprot.writeMessageBegin('closeUpdate', TMessageType.CALL, self._seqid)
    args = closeUpdate_args()
    args.updateID = updateID
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_closeUpdate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = closeUpdate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.nssi != None:
      raise result.nssi
    raise TApplicationException(TApplicationException.MISSING_RESULT, "closeUpdate failed: unknown result");

  def update(self, credentials, keyExtent, mutation):
    self.send_update(credentials, keyExtent, mutation)
    self.recv_update()

  def send_update(self, credentials, keyExtent, mutation):
    self._oprot.writeMessageBegin('update', TMessageType.CALL, self._seqid)
    args = update_args()
    args.credentials = credentials
    args.keyExtent = keyExtent
    args.mutation = mutation
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = update_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.sec != None:
      raise result.sec
    if result.nste != None:
      raise result.nste
    if result.cve != None:
      raise result.cve
    return

  def bulkImport(self, credentials, files):
    self.send_bulkImport(credentials, files)
    return self.recv_bulkImport()

  def send_bulkImport(self, credentials, files):
    self._oprot.writeMessageBegin('bulkImport', TMessageType.CALL, self._seqid)
    args = bulkImport_args()
    args.credentials = credentials
    args.files = files
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_bulkImport(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = bulkImport_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.sec != None:
      raise result.sec
    raise TApplicationException(TApplicationException.MISSING_RESULT, "bulkImport failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["startScan"] = Processor.process_startScan
    self._processMap["continueScan"] = Processor.process_continueScan
    self._processMap["closeScan"] = Processor.process_closeScan
    self._processMap["startMultiScan"] = Processor.process_startMultiScan
    self._processMap["continueMultiScan"] = Processor.process_continueMultiScan
    self._processMap["closeMultiScan"] = Processor.process_closeMultiScan
    self._processMap["startUpdate"] = Processor.process_startUpdate
    self._processMap["setUpdateTablet"] = Processor.process_setUpdateTablet
    self._processMap["applyUpdate"] = Processor.process_applyUpdate
    self._processMap["closeUpdate"] = Processor.process_closeUpdate
    self._processMap["update"] = Processor.process_update
    self._processMap["bulkImport"] = Processor.process_bulkImport

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_startScan(self, seqid, iprot, oprot):
    args = startScan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startScan_result()
    try:
      result.success = self._handler.startScan(args.credentials, args.extent, args.range, args.columns, args.batchSize, args.ssiList, args.ssio, args.authorizations)
    except ThriftSecurityException, sec:
      result.sec = sec
    except NotServingTabletException, nste:
      result.nste = nste
    oprot.writeMessageBegin("startScan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_continueScan(self, seqid, iprot, oprot):
    args = continueScan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = continueScan_result()
    try:
      result.success = self._handler.continueScan(args.scanID)
    except NoSuchScanIDException, nssi:
      result.nssi = nssi
    except NotServingTabletException, nste:
      result.nste = nste
    oprot.writeMessageBegin("continueScan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_closeScan(self, seqid, iprot, oprot):
    args = closeScan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.closeScan(args.scanID)
    return

  def process_startMultiScan(self, seqid, iprot, oprot):
    args = startMultiScan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startMultiScan_result()
    try:
      result.success = self._handler.startMultiScan(args.credentials, args.batch, args.columns, args.ssiList, args.ssio, args.authorizations)
    except ThriftSecurityException, sec:
      result.sec = sec
    oprot.writeMessageBegin("startMultiScan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_continueMultiScan(self, seqid, iprot, oprot):
    args = continueMultiScan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = continueMultiScan_result()
    try:
      result.success = self._handler.continueMultiScan(args.scanID)
    except NoSuchScanIDException, nssi:
      result.nssi = nssi
    oprot.writeMessageBegin("continueMultiScan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_closeMultiScan(self, seqid, iprot, oprot):
    args = closeMultiScan_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = closeMultiScan_result()
    try:
      result.success = self._handler.closeMultiScan(args.scanID)
    except NoSuchScanIDException, nssi:
      result.nssi = nssi
    oprot.writeMessageBegin("closeMultiScan", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startUpdate(self, seqid, iprot, oprot):
    args = startUpdate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startUpdate_result()
    try:
      result.success = self._handler.startUpdate(args.credentials)
    except ThriftSecurityException, sec:
      result.sec = sec
    oprot.writeMessageBegin("startUpdate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setUpdateTablet(self, seqid, iprot, oprot):
    args = setUpdateTablet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.setUpdateTablet(args.updateID, args.keyExtent)
    return

  def process_applyUpdate(self, seqid, iprot, oprot):
    args = applyUpdate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.applyUpdate(args.updateID, args.mutation)
    return

  def process_closeUpdate(self, seqid, iprot, oprot):
    args = closeUpdate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = closeUpdate_result()
    try:
      result.success = self._handler.closeUpdate(args.updateID)
    except NoSuchScanIDException, nssi:
      result.nssi = nssi
    oprot.writeMessageBegin("closeUpdate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update(self, seqid, iprot, oprot):
    args = update_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_result()
    try:
      self._handler.update(args.credentials, args.keyExtent, args.mutation)
    except ThriftSecurityException, sec:
      result.sec = sec
    except NotServingTabletException, nste:
      result.nste = nste
    except ConstraintViolationException, cve:
      result.cve = cve
    oprot.writeMessageBegin("update", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_bulkImport(self, seqid, iprot, oprot):
    args = bulkImport_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = bulkImport_result()
    try:
      result.success = self._handler.bulkImport(args.credentials, args.files)
    except ThriftSecurityException, sec:
      result.sec = sec
    oprot.writeMessageBegin("bulkImport", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class startScan_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'credentials', (security.ttypes.AuthInfo, security.ttypes.AuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'extent', (data.ttypes.KeyExtent, data.ttypes.KeyExtent.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'range', (data.ttypes.Range, data.ttypes.Range.thrift_spec), None, ), # 3
    (4, TType.LIST, 'columns', (TType.STRUCT,(data.ttypes.Column, data.ttypes.Column.thrift_spec)), None, ), # 4
    (5, TType.I32, 'batchSize', None, None, ), # 5
    (6, TType.LIST, 'ssiList', (TType.STRUCT,(data.ttypes.IterInfo, data.ttypes.IterInfo.thrift_spec)), None, ), # 6
    (7, TType.MAP, 'ssio', (TType.STRING,None,TType.MAP,(TType.STRING,None,TType.STRING,None)), None, ), # 7
    (8, TType.SET, 'authorizations', (TType.I16,None), None, ), # 8
  )

  def __init__(self, d=None):
    self.credentials = None
    self.extent = None
    self.range = None
    self.columns = None
    self.batchSize = None
    self.ssiList = None
    self.ssio = None
    self.authorizations = None
    if isinstance(d, dict):
      if 'credentials' in d:
        self.credentials = d['credentials']
      if 'extent' in d:
        self.extent = d['extent']
      if 'range' in d:
        self.range = d['range']
      if 'columns' in d:
        self.columns = d['columns']
      if 'batchSize' in d:
        self.batchSize = d['batchSize']
      if 'ssiList' in d:
        self.ssiList = d['ssiList']
      if 'ssio' in d:
        self.ssio = d['ssio']
      if 'authorizations' in d:
        self.authorizations = d['authorizations']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.credentials = security.ttypes.AuthInfo()
          self.credentials.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.extent = data.ttypes.KeyExtent()
          self.extent.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.range = data.ttypes.Range()
          self.range.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.columns = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = data.ttypes.Column()
            _elem19.read(iprot)
            self.columns.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.batchSize = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.ssiList = []
          (_etype23, _size20) = iprot.readListBegin()
          for _i24 in xrange(_size20):
            _elem25 = data.ttypes.IterInfo()
            _elem25.read(iprot)
            self.ssiList.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.ssio = {}
          (_ktype27, _vtype28, _size26 ) = iprot.readMapBegin() 
          for _i30 in xrange(_size26):
            _key31 = iprot.readString();
            _val32 = {}
            (_ktype34, _vtype35, _size33 ) = iprot.readMapBegin() 
            for _i37 in xrange(_size33):
              _key38 = iprot.readString();
              _val39 = iprot.readString();
              _val32[_key38] = _val39
            iprot.readMapEnd()
            self.ssio[_key31] = _val32
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.SET:
          self.authorizations = set()
          (_etype43, _size40) = iprot.readSetBegin()
          for _i44 in xrange(_size40):
            _elem45 = iprot.readI16();
            self.authorizations.add(_elem45)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startScan_args')
    if self.credentials != None:
      oprot.writeFieldBegin('credentials', TType.STRUCT, 1)
      self.credentials.write(oprot)
      oprot.writeFieldEnd()
    if self.extent != None:
      oprot.writeFieldBegin('extent', TType.STRUCT, 2)
      self.extent.write(oprot)
      oprot.writeFieldEnd()
    if self.range != None:
      oprot.writeFieldBegin('range', TType.STRUCT, 3)
      self.range.write(oprot)
      oprot.writeFieldEnd()
    if self.columns != None:
      oprot.writeFieldBegin('columns', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter46 in self.columns:
        iter46.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.batchSize != None:
      oprot.writeFieldBegin('batchSize', TType.I32, 5)
      oprot.writeI32(self.batchSize)
      oprot.writeFieldEnd()
    if self.ssiList != None:
      oprot.writeFieldBegin('ssiList', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.ssiList))
      for iter47 in self.ssiList:
        iter47.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ssio != None:
      oprot.writeFieldBegin('ssio', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.ssio))
      for kiter48,viter49 in self.ssio.items():
        oprot.writeString(kiter48)
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter49))
        for kiter50,viter51 in viter49.items():
          oprot.writeString(kiter50)
          oprot.writeString(viter51)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.authorizations != None:
      oprot.writeFieldBegin('authorizations', TType.SET, 8)
      oprot.writeSetBegin(TType.I16, len(self.authorizations))
      for iter52 in self.authorizations:
        oprot.writeI16(iter52)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startScan_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (data.ttypes.InitialScan, data.ttypes.InitialScan.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nste', (NotServingTabletException, NotServingTabletException.thrift_spec), None, ), # 2
  )

  def __init__(self, d=None):
    self.success = None
    self.sec = None
    self.nste = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'sec' in d:
        self.sec = d['sec']
      if 'nste' in d:
        self.nste = d['nste']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = data.ttypes.InitialScan()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nste = NotServingTabletException()
          self.nste.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startScan_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    if self.nste != None:
      oprot.writeFieldBegin('nste', TType.STRUCT, 2)
      self.nste.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class continueScan_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scanID', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.scanID = None
    if isinstance(d, dict):
      if 'scanID' in d:
        self.scanID = d['scanID']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scanID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('continueScan_args')
    if self.scanID != None:
      oprot.writeFieldBegin('scanID', TType.I64, 1)
      oprot.writeI64(self.scanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class continueScan_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (data.ttypes.ScanResult, data.ttypes.ScanResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'nssi', (NoSuchScanIDException, NoSuchScanIDException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nste', (NotServingTabletException, NotServingTabletException.thrift_spec), None, ), # 2
  )

  def __init__(self, d=None):
    self.success = None
    self.nssi = None
    self.nste = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'nssi' in d:
        self.nssi = d['nssi']
      if 'nste' in d:
        self.nste = d['nste']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = data.ttypes.ScanResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.nssi = NoSuchScanIDException()
          self.nssi.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nste = NotServingTabletException()
          self.nste.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('continueScan_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.nssi != None:
      oprot.writeFieldBegin('nssi', TType.STRUCT, 1)
      self.nssi.write(oprot)
      oprot.writeFieldEnd()
    if self.nste != None:
      oprot.writeFieldBegin('nste', TType.STRUCT, 2)
      self.nste.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeScan_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scanID', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.scanID = None
    if isinstance(d, dict):
      if 'scanID' in d:
        self.scanID = d['scanID']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scanID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeScan_args')
    if self.scanID != None:
      oprot.writeFieldBegin('scanID', TType.I64, 1)
      oprot.writeI64(self.scanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeScan_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeScan_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startMultiScan_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'credentials', (security.ttypes.AuthInfo, security.ttypes.AuthInfo.thrift_spec), None, ), # 1
    (2, TType.MAP, 'batch', (TType.STRUCT,(data.ttypes.KeyExtent, data.ttypes.KeyExtent.thrift_spec),TType.LIST,(TType.STRUCT,(data.ttypes.Range, data.ttypes.Range.thrift_spec))), None, ), # 2
    (3, TType.LIST, 'columns', (TType.STRUCT,(data.ttypes.Column, data.ttypes.Column.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'ssiList', (TType.STRUCT,(data.ttypes.IterInfo, data.ttypes.IterInfo.thrift_spec)), None, ), # 4
    (5, TType.MAP, 'ssio', (TType.STRING,None,TType.MAP,(TType.STRING,None,TType.STRING,None)), None, ), # 5
    (6, TType.SET, 'authorizations', (TType.I16,None), None, ), # 6
  )

  def __init__(self, d=None):
    self.credentials = None
    self.batch = None
    self.columns = None
    self.ssiList = None
    self.ssio = None
    self.authorizations = None
    if isinstance(d, dict):
      if 'credentials' in d:
        self.credentials = d['credentials']
      if 'batch' in d:
        self.batch = d['batch']
      if 'columns' in d:
        self.columns = d['columns']
      if 'ssiList' in d:
        self.ssiList = d['ssiList']
      if 'ssio' in d:
        self.ssio = d['ssio']
      if 'authorizations' in d:
        self.authorizations = d['authorizations']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.credentials = security.ttypes.AuthInfo()
          self.credentials.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.batch = {}
          (_ktype54, _vtype55, _size53 ) = iprot.readMapBegin() 
          for _i57 in xrange(_size53):
            _key58 = data.ttypes.KeyExtent()
            _key58.read(iprot)
            _val59 = []
            (_etype63, _size60) = iprot.readListBegin()
            for _i64 in xrange(_size60):
              _elem65 = data.ttypes.Range()
              _elem65.read(iprot)
              _val59.append(_elem65)
            iprot.readListEnd()
            self.batch[_key58] = _val59
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.columns = []
          (_etype69, _size66) = iprot.readListBegin()
          for _i70 in xrange(_size66):
            _elem71 = data.ttypes.Column()
            _elem71.read(iprot)
            self.columns.append(_elem71)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.ssiList = []
          (_etype75, _size72) = iprot.readListBegin()
          for _i76 in xrange(_size72):
            _elem77 = data.ttypes.IterInfo()
            _elem77.read(iprot)
            self.ssiList.append(_elem77)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.ssio = {}
          (_ktype79, _vtype80, _size78 ) = iprot.readMapBegin() 
          for _i82 in xrange(_size78):
            _key83 = iprot.readString();
            _val84 = {}
            (_ktype86, _vtype87, _size85 ) = iprot.readMapBegin() 
            for _i89 in xrange(_size85):
              _key90 = iprot.readString();
              _val91 = iprot.readString();
              _val84[_key90] = _val91
            iprot.readMapEnd()
            self.ssio[_key83] = _val84
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.SET:
          self.authorizations = set()
          (_etype95, _size92) = iprot.readSetBegin()
          for _i96 in xrange(_size92):
            _elem97 = iprot.readI16();
            self.authorizations.add(_elem97)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startMultiScan_args')
    if self.credentials != None:
      oprot.writeFieldBegin('credentials', TType.STRUCT, 1)
      self.credentials.write(oprot)
      oprot.writeFieldEnd()
    if self.batch != None:
      oprot.writeFieldBegin('batch', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(self.batch))
      for kiter98,viter99 in self.batch.items():
        kiter98.write(oprot)
        oprot.writeListBegin(TType.STRUCT, len(viter99))
        for iter100 in viter99:
          iter100.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.columns != None:
      oprot.writeFieldBegin('columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter101 in self.columns:
        iter101.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ssiList != None:
      oprot.writeFieldBegin('ssiList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.ssiList))
      for iter102 in self.ssiList:
        iter102.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ssio != None:
      oprot.writeFieldBegin('ssio', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.ssio))
      for kiter103,viter104 in self.ssio.items():
        oprot.writeString(kiter103)
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(viter104))
        for kiter105,viter106 in viter104.items():
          oprot.writeString(kiter105)
          oprot.writeString(viter106)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.authorizations != None:
      oprot.writeFieldBegin('authorizations', TType.SET, 6)
      oprot.writeSetBegin(TType.I16, len(self.authorizations))
      for iter107 in self.authorizations:
        oprot.writeI16(iter107)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startMultiScan_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (data.ttypes.InitialScan, data.ttypes.InitialScan.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.sec = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'sec' in d:
        self.sec = d['sec']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = data.ttypes.InitialScan()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startMultiScan_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class continueMultiScan_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scanID', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.scanID = None
    if isinstance(d, dict):
      if 'scanID' in d:
        self.scanID = d['scanID']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scanID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('continueMultiScan_args')
    if self.scanID != None:
      oprot.writeFieldBegin('scanID', TType.I64, 1)
      oprot.writeI64(self.scanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class continueMultiScan_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (data.ttypes.ScanResult, data.ttypes.ScanResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'nssi', (NoSuchScanIDException, NoSuchScanIDException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.nssi = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'nssi' in d:
        self.nssi = d['nssi']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = data.ttypes.ScanResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.nssi = NoSuchScanIDException()
          self.nssi.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('continueMultiScan_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.nssi != None:
      oprot.writeFieldBegin('nssi', TType.STRUCT, 1)
      self.nssi.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeMultiScan_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'scanID', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.scanID = None
    if isinstance(d, dict):
      if 'scanID' in d:
        self.scanID = d['scanID']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.scanID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeMultiScan_args')
    if self.scanID != None:
      oprot.writeFieldBegin('scanID', TType.I64, 1)
      oprot.writeI64(self.scanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeMultiScan_result:

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRUCT,(data.ttypes.KeyExtent, data.ttypes.KeyExtent.thrift_spec),TType.LIST,(TType.STRUCT,(data.ttypes.Range, data.ttypes.Range.thrift_spec))), None, ), # 0
    (1, TType.STRUCT, 'nssi', (NoSuchScanIDException, NoSuchScanIDException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.nssi = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'nssi' in d:
        self.nssi = d['nssi']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype109, _vtype110, _size108 ) = iprot.readMapBegin() 
          for _i112 in xrange(_size108):
            _key113 = data.ttypes.KeyExtent()
            _key113.read(iprot)
            _val114 = []
            (_etype118, _size115) = iprot.readListBegin()
            for _i119 in xrange(_size115):
              _elem120 = data.ttypes.Range()
              _elem120.read(iprot)
              _val114.append(_elem120)
            iprot.readListEnd()
            self.success[_key113] = _val114
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.nssi = NoSuchScanIDException()
          self.nssi.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeMultiScan_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRUCT, TType.LIST, len(self.success))
      for kiter121,viter122 in self.success.items():
        kiter121.write(oprot)
        oprot.writeListBegin(TType.STRUCT, len(viter122))
        for iter123 in viter122:
          iter123.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.nssi != None:
      oprot.writeFieldBegin('nssi', TType.STRUCT, 1)
      self.nssi.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startUpdate_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'credentials', (security.ttypes.AuthInfo, security.ttypes.AuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.credentials = None
    if isinstance(d, dict):
      if 'credentials' in d:
        self.credentials = d['credentials']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.credentials = security.ttypes.AuthInfo()
          self.credentials.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startUpdate_args')
    if self.credentials != None:
      oprot.writeFieldBegin('credentials', TType.STRUCT, 1)
      self.credentials.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startUpdate_result:

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.sec = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'sec' in d:
        self.sec = d['sec']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startUpdate_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setUpdateTablet_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'updateID', None, None, ), # 1
    (2, TType.STRUCT, 'keyExtent', (data.ttypes.KeyExtent, data.ttypes.KeyExtent.thrift_spec), None, ), # 2
  )

  def __init__(self, d=None):
    self.updateID = None
    self.keyExtent = None
    if isinstance(d, dict):
      if 'updateID' in d:
        self.updateID = d['updateID']
      if 'keyExtent' in d:
        self.keyExtent = d['keyExtent']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.updateID = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.keyExtent = data.ttypes.KeyExtent()
          self.keyExtent.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setUpdateTablet_args')
    if self.updateID != None:
      oprot.writeFieldBegin('updateID', TType.I64, 1)
      oprot.writeI64(self.updateID)
      oprot.writeFieldEnd()
    if self.keyExtent != None:
      oprot.writeFieldBegin('keyExtent', TType.STRUCT, 2)
      self.keyExtent.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setUpdateTablet_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setUpdateTablet_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class applyUpdate_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'updateID', None, None, ), # 1
    (2, TType.STRUCT, 'mutation', (data.ttypes.Mutation, data.ttypes.Mutation.thrift_spec), None, ), # 2
  )

  def __init__(self, d=None):
    self.updateID = None
    self.mutation = None
    if isinstance(d, dict):
      if 'updateID' in d:
        self.updateID = d['updateID']
      if 'mutation' in d:
        self.mutation = d['mutation']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.updateID = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.mutation = data.ttypes.Mutation()
          self.mutation.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('applyUpdate_args')
    if self.updateID != None:
      oprot.writeFieldBegin('updateID', TType.I64, 1)
      oprot.writeI64(self.updateID)
      oprot.writeFieldEnd()
    if self.mutation != None:
      oprot.writeFieldBegin('mutation', TType.STRUCT, 2)
      self.mutation.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class applyUpdate_result:

  thrift_spec = (
  )

  def __init__(self, d=None):
    pass

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('applyUpdate_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeUpdate_args:

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'updateID', None, None, ), # 1
  )

  def __init__(self, d=None):
    self.updateID = None
    if isinstance(d, dict):
      if 'updateID' in d:
        self.updateID = d['updateID']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.updateID = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeUpdate_args')
    if self.updateID != None:
      oprot.writeFieldBegin('updateID', TType.I64, 1)
      oprot.writeI64(self.updateID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class closeUpdate_result:

  thrift_spec = (
    (0, TType.STRUCT, 'success', (data.ttypes.UpdateErrors, data.ttypes.UpdateErrors.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'nssi', (NoSuchScanIDException, NoSuchScanIDException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.nssi = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'nssi' in d:
        self.nssi = d['nssi']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = data.ttypes.UpdateErrors()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.nssi = NoSuchScanIDException()
          self.nssi.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('closeUpdate_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.nssi != None:
      oprot.writeFieldBegin('nssi', TType.STRUCT, 1)
      self.nssi.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'credentials', (security.ttypes.AuthInfo, security.ttypes.AuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'keyExtent', (data.ttypes.KeyExtent, data.ttypes.KeyExtent.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'mutation', (data.ttypes.Mutation, data.ttypes.Mutation.thrift_spec), None, ), # 3
  )

  def __init__(self, d=None):
    self.credentials = None
    self.keyExtent = None
    self.mutation = None
    if isinstance(d, dict):
      if 'credentials' in d:
        self.credentials = d['credentials']
      if 'keyExtent' in d:
        self.keyExtent = d['keyExtent']
      if 'mutation' in d:
        self.mutation = d['mutation']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.credentials = security.ttypes.AuthInfo()
          self.credentials.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.keyExtent = data.ttypes.KeyExtent()
          self.keyExtent.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.mutation = data.ttypes.Mutation()
          self.mutation.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_args')
    if self.credentials != None:
      oprot.writeFieldBegin('credentials', TType.STRUCT, 1)
      self.credentials.write(oprot)
      oprot.writeFieldEnd()
    if self.keyExtent != None:
      oprot.writeFieldBegin('keyExtent', TType.STRUCT, 2)
      self.keyExtent.write(oprot)
      oprot.writeFieldEnd()
    if self.mutation != None:
      oprot.writeFieldBegin('mutation', TType.STRUCT, 3)
      self.mutation.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_result:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nste', (NotServingTabletException, NotServingTabletException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'cve', (ConstraintViolationException, ConstraintViolationException.thrift_spec), None, ), # 3
  )

  def __init__(self, d=None):
    self.sec = None
    self.nste = None
    self.cve = None
    if isinstance(d, dict):
      if 'sec' in d:
        self.sec = d['sec']
      if 'nste' in d:
        self.nste = d['nste']
      if 'cve' in d:
        self.cve = d['cve']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nste = NotServingTabletException()
          self.nste.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.cve = ConstraintViolationException()
          self.cve.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_result')
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    if self.nste != None:
      oprot.writeFieldBegin('nste', TType.STRUCT, 2)
      self.nste.write(oprot)
      oprot.writeFieldEnd()
    if self.cve != None:
      oprot.writeFieldBegin('cve', TType.STRUCT, 3)
      self.cve.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bulkImport_args:

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'credentials', (security.ttypes.AuthInfo, security.ttypes.AuthInfo.thrift_spec), None, ), # 1
    (2, TType.MAP, 'files', (TType.STRUCT,(data.ttypes.KeyExtent, data.ttypes.KeyExtent.thrift_spec),TType.MAP,(TType.STRING,None,TType.I64,None)), None, ), # 2
  )

  def __init__(self, d=None):
    self.credentials = None
    self.files = None
    if isinstance(d, dict):
      if 'credentials' in d:
        self.credentials = d['credentials']
      if 'files' in d:
        self.files = d['files']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.credentials = security.ttypes.AuthInfo()
          self.credentials.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.files = {}
          (_ktype125, _vtype126, _size124 ) = iprot.readMapBegin() 
          for _i128 in xrange(_size124):
            _key129 = data.ttypes.KeyExtent()
            _key129.read(iprot)
            _val130 = {}
            (_ktype132, _vtype133, _size131 ) = iprot.readMapBegin() 
            for _i135 in xrange(_size131):
              _key136 = iprot.readString();
              _val137 = iprot.readI64();
              _val130[_key136] = _val137
            iprot.readMapEnd()
            self.files[_key129] = _val130
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bulkImport_args')
    if self.credentials != None:
      oprot.writeFieldBegin('credentials', TType.STRUCT, 1)
      self.credentials.write(oprot)
      oprot.writeFieldEnd()
    if self.files != None:
      oprot.writeFieldBegin('files', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRUCT, TType.MAP, len(self.files))
      for kiter138,viter139 in self.files.items():
        kiter138.write(oprot)
        oprot.writeMapBegin(TType.STRING, TType.I64, len(viter139))
        for kiter140,viter141 in viter139.items():
          oprot.writeString(kiter140)
          oprot.writeI64(viter141)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class bulkImport_result:

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(data.ttypes.KeyExtent, data.ttypes.KeyExtent.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'sec', (security.ttypes.ThriftSecurityException, security.ttypes.ThriftSecurityException.thrift_spec), None, ), # 1
  )

  def __init__(self, d=None):
    self.success = None
    self.sec = None
    if isinstance(d, dict):
      if 'success' in d:
        self.success = d['success']
      if 'sec' in d:
        self.sec = d['sec']

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype145, _size142) = iprot.readListBegin()
          for _i146 in xrange(_size142):
            _elem147 = data.ttypes.KeyExtent()
            _elem147.read(iprot)
            self.success.append(_elem147)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.sec = security.ttypes.ThriftSecurityException()
          self.sec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('bulkImport_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter148 in self.success:
        iter148.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.STRUCT, 1)
      self.sec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self): 
    return str(self.__dict__)

  def __repr__(self): 
    return repr(self.__dict__)

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


